const mongoose = require('mongoose');

const seoMetaSchema = new mongoose.Schema(
  {
    entityType: {
      type: String,
      required: true,
      enum: ['product', 'category', 'vendor', 'page'],
      index: true,
    },
    entityId: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      refPath: 'entityTypeRef',
    },
    entityTypeRef: {
      type: String,
      enum: ['Product', 'Category', 'Vendor', 'Page'],
    },
    languageCode: {
      type: String,
      default: 'en',
      index: true,
    },
    slug: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    metaTitle: {
      type: String,
      maxlength: [70, 'Meta title must be less than 70 characters'],
      trim: true,
    },
    metaDescription: {
      type: String,
      maxlength: [160, 'Meta description must be less than 160 characters'],
      trim: true,
    },
    metaKeywords: [{
      type: String,
      trim: true,
    }],
    // Open Graph tags
    ogTitle: {
      type: String,
      maxlength: 95,
      trim: true,
    },
    ogDescription: {
      type: String,
      maxlength: 200,
      trim: true,
    },
    ogImage: {
      type: String,
    },
    ogType: {
      type: String,
      default: 'website',
      enum: ['website', 'article', 'product', 'profile'],
    },
    // Twitter Card
    twitterCard: {
      type: String,
      enum: ['summary', 'summary_large_image', 'app', 'player'],
      default: 'summary_large_image',
    },
    twitterTitle: String,
    twitterDescription: String,
    twitterImage: String,
    // Technical SEO
    canonicalUrl: {
      type: String,
      trim: true,
    },
    robotsDirective: {
      type: String,
      default: 'index,follow',
      enum: ['index,follow', 'noindex,follow', 'index,nofollow', 'noindex,nofollow'],
    },
    // JSON-LD Structured Data
    schemaJson: {
      type: mongoose.Schema.Types.Mixed,
    },
    // Sitemap settings
    sitemapPriority: {
      type: Number,
      min: 0,
      max: 1,
      default: 0.5,
    },
    sitemapChangeFreq: {
      type: String,
      enum: ['always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', 'never'],
      default: 'weekly',
    },
    excludeFromSitemap: {
      type: Boolean,
      default: false,
    },
    // Generation info
    isAutoGenerated: {
      type: Boolean,
      default: true,
    },
    lastModifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
    seoScore: {
      type: Number,
      min: 0,
      max: 100,
    },
    seoIssues: [{
      type: {
        type: String,
        enum: ['missing_title', 'missing_description', 'title_too_long', 'title_too_short',
               'description_too_long', 'description_too_short', 'missing_h1', 'duplicate_content',
               'missing_image_alt', 'missing_og_image', 'missing_schema'],
      },
      message: String,
      severity: {
        type: String,
        enum: ['error', 'warning', 'info'],
      },
    }],
  },
  {
    timestamps: true,
  }
);

// Compound indexes
seoMetaSchema.index({ entityType: 1, entityId: 1, languageCode: 1 }, { unique: true });
seoMetaSchema.index({ slug: 1, languageCode: 1 }, { unique: true });
seoMetaSchema.index({ entityType: 1, excludeFromSitemap: 1 });

// Virtual for entity type ref mapping
seoMetaSchema.pre('save', function(next) {
  const typeMap = {
    product: 'Product',
    category: 'Category',
    vendor: 'Vendor',
    page: 'Page',
  };
  this.entityTypeRef = typeMap[this.entityType];
  next();
});

/**
 * Generate slug from text
 */
seoMetaSchema.statics.generateSlug = function(text, entityType) {
  let slug = text
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');

  // Add entity type prefix for uniqueness
  if (entityType === 'category') {
    slug = `c-${slug}`;
  } else if (entityType === 'vendor') {
    slug = `v-${slug}`;
  } else if (entityType === 'page') {
    slug = `p-${slug}`;
  }

  return slug;
};

/**
 * Check if slug exists
 */
seoMetaSchema.statics.slugExists = async function(slug, languageCode = 'en', excludeId = null) {
  const query = { slug, languageCode };
  if (excludeId) {
    query._id = { $ne: excludeId };
  }
  const existing = await this.findOne(query);
  return !!existing;
};

/**
 * Generate unique slug
 */
seoMetaSchema.statics.generateUniqueSlug = async function(text, entityType, languageCode = 'en') {
  let baseSlug = this.generateSlug(text, entityType);
  let slug = baseSlug;
  let counter = 1;

  while (await this.slugExists(slug, languageCode)) {
    slug = `${baseSlug}-${counter}`;
    counter++;
  }

  return slug;
};

/**
 * Auto-generate SEO meta from entity
 */
seoMetaSchema.statics.generateFromEntity = async function(entityType, entity, languageCode = 'en') {
  let metaTitle, metaDescription, schemaJson, slug;

  switch (entityType) {
    case 'product':
      metaTitle = entity.name.substring(0, 60);
      metaDescription = entity.description?.substring(0, 155) || `Buy ${entity.name} at best prices`;
      slug = await this.generateUniqueSlug(entity.name, entityType, languageCode);
      schemaJson = {
        '@context': 'https://schema.org',
        '@type': 'Product',
        name: entity.name,
        description: entity.description,
        image: entity.images?.[0]?.url,
        sku: entity.sku,
        brand: {
          '@type': 'Brand',
          name: entity.vendor?.storeName || 'Unknown',
        },
        offers: {
          '@type': 'Offer',
          price: entity.price,
          priceCurrency: 'PKR',
          availability: entity.stock > 0 ? 'https://schema.org/InStock' : 'https://schema.org/OutOfStock',
          seller: {
            '@type': 'Organization',
            name: entity.vendor?.storeName,
          },
        },
        aggregateRating: entity.numReviews > 0 ? {
          '@type': 'AggregateRating',
          ratingValue: entity.ratings,
          reviewCount: entity.numReviews,
        } : undefined,
      };
      break;

    case 'category':
      metaTitle = `${entity.name} - Shop Products`;
      metaDescription = entity.description?.substring(0, 155) || `Browse ${entity.name} products at best prices`;
      slug = await this.generateUniqueSlug(entity.name, entityType, languageCode);
      schemaJson = {
        '@context': 'https://schema.org',
        '@type': 'CollectionPage',
        name: entity.name,
        description: entity.description,
      };
      break;

    case 'vendor':
      metaTitle = `${entity.storeName} - Official Store`;
      metaDescription = entity.description?.substring(0, 155) || `Shop from ${entity.storeName}'s official store`;
      slug = await this.generateUniqueSlug(entity.storeName, entityType, languageCode);
      schemaJson = {
        '@context': 'https://schema.org',
        '@type': 'Organization',
        name: entity.storeName,
        description: entity.description,
        logo: entity.logo,
        url: entity.website,
      };
      break;

    case 'page':
      metaTitle = entity.title?.substring(0, 60);
      metaDescription = entity.excerpt?.substring(0, 155) || entity.content?.substring(0, 155);
      slug = await this.generateUniqueSlug(entity.title, entityType, languageCode);
      schemaJson = {
        '@context': 'https://schema.org',
        '@type': 'WebPage',
        name: entity.title,
        description: metaDescription,
      };
      break;
  }

  return {
    entityType,
    entityId: entity._id,
    languageCode,
    slug,
    metaTitle,
    metaDescription,
    ogTitle: metaTitle,
    ogDescription: metaDescription,
    ogImage: entity.images?.[0]?.url || entity.logo,
    schemaJson,
    isAutoGenerated: true,
  };
};

/**
 * Find or create SEO meta for entity
 */
seoMetaSchema.statics.findOrCreateForEntity = async function(entityType, entityId, entity, languageCode = 'en') {
  let seoMeta = await this.findOne({ entityType, entityId, languageCode });

  if (!seoMeta) {
    const generated = await this.generateFromEntity(entityType, entity, languageCode);
    seoMeta = await this.create(generated);
  }

  return seoMeta;
};

/**
 * Calculate SEO score
 */
seoMetaSchema.methods.calculateSeoScore = function() {
  let score = 0;
  const issues = [];

  // Title checks (30 points)
  if (this.metaTitle) {
    score += 10;
    if (this.metaTitle.length >= 30 && this.metaTitle.length <= 60) {
      score += 20;
    } else if (this.metaTitle.length < 30) {
      score += 10;
      issues.push({ type: 'title_too_short', message: 'Title is too short', severity: 'warning' });
    } else {
      score += 10;
      issues.push({ type: 'title_too_long', message: 'Title is too long', severity: 'warning' });
    }
  } else {
    issues.push({ type: 'missing_title', message: 'Meta title is missing', severity: 'error' });
  }

  // Description checks (30 points)
  if (this.metaDescription) {
    score += 10;
    if (this.metaDescription.length >= 120 && this.metaDescription.length <= 155) {
      score += 20;
    } else if (this.metaDescription.length < 120) {
      score += 10;
      issues.push({ type: 'description_too_short', message: 'Description is too short', severity: 'warning' });
    } else {
      score += 10;
      issues.push({ type: 'description_too_long', message: 'Description is too long', severity: 'warning' });
    }
  } else {
    issues.push({ type: 'missing_description', message: 'Meta description is missing', severity: 'error' });
  }

  // OG image (15 points)
  if (this.ogImage) {
    score += 15;
  } else {
    issues.push({ type: 'missing_og_image', message: 'OG image is missing', severity: 'warning' });
  }

  // Schema (15 points)
  if (this.schemaJson && Object.keys(this.schemaJson).length > 0) {
    score += 15;
  } else {
    issues.push({ type: 'missing_schema', message: 'Structured data is missing', severity: 'info' });
  }

  // Keywords (10 points)
  if (this.metaKeywords && this.metaKeywords.length > 0) {
    score += 10;
  }

  this.seoScore = Math.min(score, 100);
  this.seoIssues = issues;

  return { score: this.seoScore, issues };
};

/**
 * Get SEO audit for entity type
 */
seoMetaSchema.statics.getAudit = async function(entityType = null) {
  const matchStage = entityType ? { entityType } : {};

  const audit = await this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: '$entityType',
        total: { $sum: 1 },
        avgScore: { $avg: '$seoScore' },
        missingTitle: {
          $sum: { $cond: [{ $not: ['$metaTitle'] }, 1, 0] },
        },
        missingDescription: {
          $sum: { $cond: [{ $not: ['$metaDescription'] }, 1, 0] },
        },
        missingOgImage: {
          $sum: { $cond: [{ $not: ['$ogImage'] }, 1, 0] },
        },
        autoGenerated: {
          $sum: { $cond: ['$isAutoGenerated', 1, 0] },
        },
      },
    },
    {
      $project: {
        entityType: '$_id',
        total: 1,
        avgScore: { $round: ['$avgScore', 1] },
        missingTitle: 1,
        missingDescription: 1,
        missingOgImage: 1,
        autoGenerated: 1,
        customized: { $subtract: ['$total', '$autoGenerated'] },
      },
    },
  ]);

  return audit;
};

/**
 * Find by slug
 */
seoMetaSchema.statics.findBySlug = async function(slug, languageCode = 'en') {
  return this.findOne({ slug, languageCode }).populate('entityId');
};

const SeoMeta = mongoose.model('SeoMeta', seoMetaSchema);

module.exports = SeoMeta;
