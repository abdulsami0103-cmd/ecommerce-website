const SeoMeta = require('../models/SeoMeta');
const UrlRedirect = require('../models/UrlRedirect');
const SitemapConfig = require('../models/SitemapConfig');
const seoService = require('../services/seoService');
const sitemapGenerator = require('../jobs/sitemapGenerator');

/**
 * @desc    Get SEO meta by slug
 * @route   GET /api/seo/slug/:slug
 * @access  Public
 */
const getSeoBySlug = async (req, res) => {
  try {
    const { slug } = req.params;
    const languageCode = req.query.lang || 'en';

    const seoMeta = await seoService.getBySlug(slug, languageCode);

    if (!seoMeta) {
      return res.status(404).json({
        success: false,
        message: 'SEO meta not found for this slug',
      });
    }

    res.json({
      success: true,
      data: seoMeta,
    });
  } catch (error) {
    console.error('Get SEO by slug error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get SEO meta',
    });
  }
};

/**
 * @desc    Get SEO meta for entity
 * @route   GET /api/seo/:type/:id
 * @access  Public
 */
const getSeoForEntity = async (req, res) => {
  try {
    const { type, id } = req.params;
    const languageCode = req.query.lang || 'en';

    const seoMeta = await SeoMeta.findOne({
      entityType: type,
      entityId: id,
      languageCode,
    });

    if (!seoMeta) {
      return res.status(404).json({
        success: false,
        message: 'SEO meta not found',
      });
    }

    res.json({
      success: true,
      data: seoMeta,
    });
  } catch (error) {
    console.error('Get SEO for entity error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get SEO meta',
    });
  }
};

/**
 * @desc    Update SEO meta for entity
 * @route   PUT /api/seo/:type/:id
 * @access  Vendor/Admin
 */
const updateSeo = async (req, res) => {
  try {
    const { type, id } = req.params;
    const languageCode = req.query.lang || 'en';
    const updates = req.body;

    const seoMeta = await seoService.updateMeta(
      type,
      id,
      updates,
      req.user._id,
      languageCode
    );

    res.json({
      success: true,
      data: seoMeta,
    });
  } catch (error) {
    console.error('Update SEO error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to update SEO meta',
    });
  }
};

/**
 * @desc    Check if slug is available
 * @route   GET /api/seo/check-slug
 * @access  Public
 */
const checkSlug = async (req, res) => {
  try {
    const { slug, excludeId } = req.query;
    const languageCode = req.query.lang || 'en';

    const exists = await seoService.slugExists(slug, languageCode, excludeId);

    res.json({
      success: true,
      available: !exists,
    });
  } catch (error) {
    console.error('Check slug error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to check slug',
    });
  }
};

/**
 * @desc    Generate unique slug
 * @route   POST /api/seo/generate-slug
 * @access  Vendor/Admin
 */
const generateSlug = async (req, res) => {
  try {
    const { text, entityType } = req.body;
    const languageCode = req.query.lang || 'en';

    const slug = await seoService.generateUniqueSlug(text, entityType, languageCode);

    res.json({
      success: true,
      slug,
    });
  } catch (error) {
    console.error('Generate slug error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to generate slug',
    });
  }
};

// ==================== ADMIN ROUTES ====================

/**
 * @desc    Get SEO audit report
 * @route   GET /api/admin/seo/audit
 * @access  Admin
 */
const getSeoAudit = async (req, res) => {
  try {
    const { entityType } = req.query;

    const audit = await seoService.getAudit(entityType || null);

    res.json({
      success: true,
      data: audit,
    });
  } catch (error) {
    console.error('Get SEO audit error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get SEO audit',
    });
  }
};

/**
 * @desc    Get all SEO metas with filters
 * @route   GET /api/admin/seo
 * @access  Admin
 */
const getAllSeoMetas = async (req, res) => {
  try {
    const {
      entityType,
      hasIssues,
      isAutoGenerated,
      search,
      page = 1,
      limit = 20,
    } = req.query;

    const query = {};

    if (entityType) query.entityType = entityType;
    if (isAutoGenerated !== undefined) query.isAutoGenerated = isAutoGenerated === 'true';
    if (hasIssues === 'true') query['seoIssues.0'] = { $exists: true };

    if (search) {
      query.$or = [
        { slug: { $regex: search, $options: 'i' } },
        { metaTitle: { $regex: search, $options: 'i' } },
      ];
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [metas, total] = await Promise.all([
      SeoMeta.find(query)
        .sort({ updatedAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
      SeoMeta.countDocuments(query),
    ]);

    res.json({
      success: true,
      data: metas,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    console.error('Get all SEO metas error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get SEO metas',
    });
  }
};

/**
 * @desc    Recalculate SEO scores
 * @route   POST /api/admin/seo/recalculate-scores
 * @access  Admin
 */
const recalculateScores = async (req, res) => {
  try {
    const { entityType } = req.body;

    const updated = await seoService.recalculateAllScores(entityType);

    res.json({
      success: true,
      message: `Recalculated SEO scores for ${updated} entities`,
      updated,
    });
  } catch (error) {
    console.error('Recalculate scores error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to recalculate scores',
    });
  }
};

// ==================== REDIRECT ROUTES ====================

/**
 * @desc    Get all redirects
 * @route   GET /api/admin/seo/redirects
 * @access  Admin
 */
const getRedirects = async (req, res) => {
  try {
    const {
      isActive,
      reason,
      search,
      sortBy = 'createdAt',
      sortOrder = 'desc',
      page = 1,
      limit = 20,
    } = req.query;

    const query = {};

    if (isActive !== undefined) query.isActive = isActive === 'true';
    if (reason) query.reason = reason;

    if (search) {
      query.$or = [
        { oldUrl: { $regex: search, $options: 'i' } },
        { newUrl: { $regex: search, $options: 'i' } },
      ];
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const sort = { [sortBy]: sortOrder === 'asc' ? 1 : -1 };

    const [redirects, total] = await Promise.all([
      UrlRedirect.find(query)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate('createdBy', 'email')
        .lean(),
      UrlRedirect.countDocuments(query),
    ]);

    res.json({
      success: true,
      data: redirects,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit)),
      },
    });
  } catch (error) {
    console.error('Get redirects error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get redirects',
    });
  }
};

/**
 * @desc    Get redirect statistics
 * @route   GET /api/admin/seo/redirects/stats
 * @access  Admin
 */
const getRedirectStats = async (req, res) => {
  try {
    const stats = await seoService.getRedirectStats();

    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    console.error('Get redirect stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get redirect stats',
    });
  }
};

/**
 * @desc    Create redirect
 * @route   POST /api/admin/seo/redirects
 * @access  Admin
 */
const createRedirect = async (req, res) => {
  try {
    const redirect = await seoService.createRedirect(req.body, req.user._id);

    res.status(201).json({
      success: true,
      data: redirect,
    });
  } catch (error) {
    console.error('Create redirect error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to create redirect',
    });
  }
};

/**
 * @desc    Update redirect
 * @route   PUT /api/admin/seo/redirects/:id
 * @access  Admin
 */
const updateRedirect = async (req, res) => {
  try {
    const redirect = await seoService.updateRedirect(req.params.id, req.body);

    if (!redirect) {
      return res.status(404).json({
        success: false,
        message: 'Redirect not found',
      });
    }

    res.json({
      success: true,
      data: redirect,
    });
  } catch (error) {
    console.error('Update redirect error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update redirect',
    });
  }
};

/**
 * @desc    Delete redirect
 * @route   DELETE /api/admin/seo/redirects/:id
 * @access  Admin
 */
const deleteRedirect = async (req, res) => {
  try {
    await seoService.deleteRedirect(req.params.id);

    res.json({
      success: true,
      message: 'Redirect deleted',
    });
  } catch (error) {
    console.error('Delete redirect error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete redirect',
    });
  }
};

/**
 * @desc    Fix redirect chains
 * @route   POST /api/admin/seo/redirects/fix-chains
 * @access  Admin
 */
const fixRedirectChains = async (req, res) => {
  try {
    const fixed = await seoService.fixRedirectChains();

    res.json({
      success: true,
      message: `Fixed ${fixed} redirect chains`,
      fixed,
    });
  } catch (error) {
    console.error('Fix redirect chains error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fix redirect chains',
    });
  }
};

/**
 * @desc    Bulk import redirects
 * @route   POST /api/admin/seo/redirects/import
 * @access  Admin
 */
const importRedirects = async (req, res) => {
  try {
    const { redirects } = req.body;

    if (!Array.isArray(redirects) || redirects.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Redirects array is required',
      });
    }

    const created = await UrlRedirect.bulkCreate(redirects, req.user._id);

    res.status(201).json({
      success: true,
      message: `Imported ${created.length} redirects`,
      created: created.length,
    });
  } catch (error) {
    console.error('Import redirects error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to import redirects',
    });
  }
};

// ==================== SITEMAP ROUTES ====================

/**
 * @desc    Get sitemap configurations
 * @route   GET /api/admin/seo/sitemap/config
 * @access  Admin
 */
const getSitemapConfig = async (req, res) => {
  try {
    const configs = await SitemapConfig.find().sort({ entityType: 1 }).lean();

    res.json({
      success: true,
      data: configs,
    });
  } catch (error) {
    console.error('Get sitemap config error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get sitemap config',
    });
  }
};

/**
 * @desc    Update sitemap configuration
 * @route   PUT /api/admin/seo/sitemap/config/:entityType
 * @access  Admin
 */
const updateSitemapConfig = async (req, res) => {
  try {
    const config = await SitemapConfig.findOneAndUpdate(
      { entityType: req.params.entityType },
      { $set: req.body },
      { new: true }
    );

    if (!config) {
      return res.status(404).json({
        success: false,
        message: 'Sitemap config not found',
      });
    }

    res.json({
      success: true,
      data: config,
    });
  } catch (error) {
    console.error('Update sitemap config error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update sitemap config',
    });
  }
};

/**
 * @desc    Get sitemap generation stats
 * @route   GET /api/admin/seo/sitemap/stats
 * @access  Admin
 */
const getSitemapStats = async (req, res) => {
  try {
    const stats = await sitemapGenerator.getStats();

    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    console.error('Get sitemap stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get sitemap stats',
    });
  }
};

/**
 * @desc    Trigger sitemap regeneration
 * @route   POST /api/admin/seo/sitemap/generate
 * @access  Admin
 */
const triggerSitemapGeneration = async (req, res) => {
  try {
    // Start generation in background
    setImmediate(() => sitemapGenerator.generateAll());

    res.json({
      success: true,
      message: 'Sitemap generation started',
    });
  } catch (error) {
    console.error('Trigger sitemap generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to trigger sitemap generation',
    });
  }
};

module.exports = {
  // Public
  getSeoBySlug,
  getSeoForEntity,
  checkSlug,

  // Vendor/Admin
  updateSeo,
  generateSlug,

  // Admin - SEO Meta
  getSeoAudit,
  getAllSeoMetas,
  recalculateScores,

  // Admin - Redirects
  getRedirects,
  getRedirectStats,
  createRedirect,
  updateRedirect,
  deleteRedirect,
  fixRedirectChains,
  importRedirects,

  // Admin - Sitemap
  getSitemapConfig,
  updateSitemapConfig,
  getSitemapStats,
  triggerSitemapGeneration,
};
