const SeoMeta = require('../models/SeoMeta');
const UrlRedirect = require('../models/UrlRedirect');

/**
 * SEO Service
 * Handles SEO meta generation, slug management, and redirects
 */
class SeoService {
  /**
   * Generate SEO meta for an entity
   */
  async generateMeta(entityType, entity, languageCode = 'en') {
    try {
      const generated = await SeoMeta.generateFromEntity(entityType, entity, languageCode);
      return generated;
    } catch (error) {
      console.error('[SeoService] Failed to generate meta:', error);
      throw error;
    }
  }

  /**
   * Find or create SEO meta for an entity
   */
  async findOrCreateMeta(entityType, entityId, entity, languageCode = 'en') {
    try {
      return await SeoMeta.findOrCreateForEntity(entityType, entityId, entity, languageCode);
    } catch (error) {
      console.error('[SeoService] Failed to find/create meta:', error);
      throw error;
    }
  }

  /**
   * Update SEO meta
   */
  async updateMeta(entityType, entityId, updates, userId = null, languageCode = 'en') {
    try {
      let seoMeta = await SeoMeta.findOne({ entityType, entityId, languageCode });

      if (!seoMeta) {
        throw new Error('SEO meta not found');
      }

      // Track slug change for redirect
      const oldSlug = seoMeta.slug;
      const newSlug = updates.slug;

      // Update fields
      Object.keys(updates).forEach(key => {
        if (updates[key] !== undefined) {
          seoMeta[key] = updates[key];
        }
      });

      seoMeta.isAutoGenerated = false;
      seoMeta.lastModifiedBy = userId;

      // Calculate SEO score
      seoMeta.calculateSeoScore();

      await seoMeta.save();

      // Create redirect if slug changed
      if (newSlug && oldSlug !== newSlug) {
        await this.createRedirectOnSlugChange(oldSlug, newSlug, entityType, entityId, userId);
      }

      return seoMeta;
    } catch (error) {
      console.error('[SeoService] Failed to update meta:', error);
      throw error;
    }
  }

  /**
   * Get SEO meta by slug
   */
  async getBySlug(slug, languageCode = 'en') {
    try {
      return await SeoMeta.findBySlug(slug, languageCode);
    } catch (error) {
      console.error('[SeoService] Failed to get by slug:', error);
      throw error;
    }
  }

  /**
   * Check if slug exists
   */
  async slugExists(slug, languageCode = 'en', excludeId = null) {
    try {
      return await SeoMeta.slugExists(slug, languageCode, excludeId);
    } catch (error) {
      console.error('[SeoService] Failed to check slug:', error);
      throw error;
    }
  }

  /**
   * Generate unique slug
   */
  async generateUniqueSlug(text, entityType, languageCode = 'en') {
    try {
      return await SeoMeta.generateUniqueSlug(text, entityType, languageCode);
    } catch (error) {
      console.error('[SeoService] Failed to generate unique slug:', error);
      throw error;
    }
  }

  /**
   * Create redirect on slug change
   */
  async createRedirectOnSlugChange(oldSlug, newSlug, entityType, entityId, userId = null) {
    try {
      return await UrlRedirect.createOnSlugChange(
        oldSlug,
        newSlug,
        entityType,
        entityId,
        userId
      );
    } catch (error) {
      console.error('[SeoService] Failed to create redirect:', error);
      // Don't throw - redirect creation is not critical
      return null;
    }
  }

  /**
   * Find redirect for URL
   */
  async findRedirect(url) {
    try {
      const redirect = await UrlRedirect.findRedirect(url);
      if (redirect) {
        // Record hit asynchronously
        setImmediate(() => redirect.recordHit());
      }
      return redirect;
    } catch (error) {
      console.error('[SeoService] Failed to find redirect:', error);
      return null;
    }
  }

  /**
   * Get SEO audit
   */
  async getAudit(entityType = null) {
    try {
      return await SeoMeta.getAudit(entityType);
    } catch (error) {
      console.error('[SeoService] Failed to get audit:', error);
      throw error;
    }
  }

  /**
   * Bulk update SEO score for all entities
   */
  async recalculateAllScores(entityType = null) {
    try {
      const query = entityType ? { entityType } : {};
      const metas = await SeoMeta.find(query);

      let updated = 0;
      for (const meta of metas) {
        meta.calculateSeoScore();
        await meta.save();
        updated++;
      }

      return updated;
    } catch (error) {
      console.error('[SeoService] Failed to recalculate scores:', error);
      throw error;
    }
  }

  /**
   * Get entities missing SEO meta
   */
  async getMissingEntities(entityType, Model) {
    try {
      // Get all entity IDs that have SEO meta
      const existingMetas = await SeoMeta.find({ entityType }).select('entityId').lean();
      const existingIds = existingMetas.map(m => m.entityId.toString());

      // Get entities without SEO meta
      const entities = await Model.find({
        _id: { $nin: existingIds },
      }).select('_id name title storeName slug').limit(100).lean();

      return entities;
    } catch (error) {
      console.error('[SeoService] Failed to get missing entities:', error);
      throw error;
    }
  }

  /**
   * Auto-generate SEO meta for missing entities
   */
  async autoGenerateMissing(entityType, Model, languageCode = 'en') {
    try {
      const missing = await this.getMissingEntities(entityType, Model);
      let created = 0;

      for (const entity of missing) {
        try {
          await this.findOrCreateMeta(entityType, entity._id, entity, languageCode);
          created++;
        } catch (err) {
          console.error(`[SeoService] Failed to create meta for ${entity._id}:`, err.message);
        }
      }

      return created;
    } catch (error) {
      console.error('[SeoService] Failed to auto-generate missing:', error);
      throw error;
    }
  }

  /**
   * Get redirect statistics
   */
  async getRedirectStats() {
    try {
      return await UrlRedirect.getStats();
    } catch (error) {
      console.error('[SeoService] Failed to get redirect stats:', error);
      throw error;
    }
  }

  /**
   * Create manual redirect
   */
  async createRedirect(data, userId = null) {
    try {
      const redirect = await UrlRedirect.create({
        ...data,
        createdBy: userId,
      });
      return redirect;
    } catch (error) {
      console.error('[SeoService] Failed to create redirect:', error);
      throw error;
    }
  }

  /**
   * Update redirect
   */
  async updateRedirect(redirectId, updates) {
    try {
      const redirect = await UrlRedirect.findByIdAndUpdate(
        redirectId,
        { $set: updates },
        { new: true }
      );
      return redirect;
    } catch (error) {
      console.error('[SeoService] Failed to update redirect:', error);
      throw error;
    }
  }

  /**
   * Delete redirect
   */
  async deleteRedirect(redirectId) {
    try {
      await UrlRedirect.findByIdAndDelete(redirectId);
      return true;
    } catch (error) {
      console.error('[SeoService] Failed to delete redirect:', error);
      throw error;
    }
  }

  /**
   * Fix redirect chains
   */
  async fixRedirectChains() {
    try {
      return await UrlRedirect.fixChains();
    } catch (error) {
      console.error('[SeoService] Failed to fix chains:', error);
      throw error;
    }
  }

  /**
   * Cleanup old redirects
   */
  async cleanupRedirects(options = {}) {
    try {
      return await UrlRedirect.cleanup(options);
    } catch (error) {
      console.error('[SeoService] Failed to cleanup redirects:', error);
      throw error;
    }
  }

  /**
   * Generate JSON-LD for product
   */
  generateProductSchema(product, vendorName) {
    return {
      '@context': 'https://schema.org',
      '@type': 'Product',
      name: product.name,
      description: product.description,
      image: product.images?.map(img => img.url) || [],
      sku: product.sku,
      mpn: product.sku,
      brand: {
        '@type': 'Brand',
        name: vendorName || 'Unknown',
      },
      offers: {
        '@type': 'Offer',
        url: product.url,
        price: product.salePrice || product.price,
        priceCurrency: 'PKR',
        priceValidUntil: product.saleEndDate || undefined,
        availability: product.stock > 0
          ? 'https://schema.org/InStock'
          : 'https://schema.org/OutOfStock',
        seller: {
          '@type': 'Organization',
          name: vendorName,
        },
      },
      aggregateRating: product.numReviews > 0 ? {
        '@type': 'AggregateRating',
        ratingValue: product.ratings,
        reviewCount: product.numReviews,
        bestRating: 5,
        worstRating: 1,
      } : undefined,
    };
  }

  /**
   * Generate JSON-LD for organization
   */
  generateOrganizationSchema(vendor) {
    return {
      '@context': 'https://schema.org',
      '@type': 'Organization',
      name: vendor.storeName,
      description: vendor.description,
      logo: vendor.logo,
      url: vendor.website,
      email: vendor.contactEmail,
      telephone: vendor.contactPhone,
      address: vendor.address ? {
        '@type': 'PostalAddress',
        streetAddress: vendor.address.street,
        addressLocality: vendor.address.city,
        addressRegion: vendor.address.state,
        postalCode: vendor.address.postalCode,
        addressCountry: vendor.address.country,
      } : undefined,
    };
  }

  /**
   * Generate JSON-LD for breadcrumbs
   */
  generateBreadcrumbSchema(items) {
    return {
      '@context': 'https://schema.org',
      '@type': 'BreadcrumbList',
      itemListElement: items.map((item, index) => ({
        '@type': 'ListItem',
        position: index + 1,
        name: item.name,
        item: item.url,
      })),
    };
  }

  /**
   * Generate JSON-LD for FAQ
   */
  generateFAQSchema(faqs) {
    return {
      '@context': 'https://schema.org',
      '@type': 'FAQPage',
      mainEntity: faqs.map(faq => ({
        '@type': 'Question',
        name: faq.question,
        acceptedAnswer: {
          '@type': 'Answer',
          text: faq.answer,
        },
      })),
    };
  }
}

module.exports = new SeoService();
